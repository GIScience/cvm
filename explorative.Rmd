---
title: "CVM in Heidelberg"
author: "Marcel Reinmuth"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    number_sections: true
    toc_float: true
    theme: cerulean
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Intro

Quick exploratory analysis of cigarette vending machine locations in Heidelberg, uncovering insights and patterns to better understand their spatial distribution.

# Setup

This section for reproducibility tbd.

## libraries

```{r import libs, message=F}
# main libraries
library(sf)
library(units)
library(tidyverse)
library(spatstat)
library(ggeffects)
library(tmap)
library(osmdata)
library(DT)
```

## Data download & preprocess

```{r read in data, warning=F}
# read in localy
# cvm <- st_read("cvm_data.gpkg", layer = "cvm", quiet=T)
# schools <- st_read("cvm_data.gpkg", layer = "schools", quiet=T)
# kindergartens <- st_read("cvm_data.gpkg", layer = "kindergarten", quiet=T)
# hd_boundary <- st_read("cvm_data.gpkg", layer = "hd bound", quiet=T)

# query osm via overpass
hd_boundary <- opq(bbox = 'Heidelberg, Germany') |>
  add_osm_feature(key = 'name', value = 'Heidelberg') |>
  add_osm_feature(key = 'admin_level', value = '6') |>
  osmdata_sf()
hd_boundary <- hd_boundary$osm_multipolygons

cvm <- opq(bbox = 'Heidelberg, Germany') |>
  add_osm_feature(key = 'vending', value = 'cigarettes') |>
  osmdata_sf()
cvm <- cvm$osm_points

osm_schools <- opq(bbox = 'Heidelberg, Germany') |>
  add_osm_feature(key = 'amenity', value = 'school') |>
  osmdata_sf()

osm_kindergarten <- opq(bbox = 'Heidelberg, Germany') |>
  add_osm_feature(key = 'amenity', value = 'kindergarten') |>
  osmdata_sf()




# Check for overlaps. Are schools/kindergartens all mapped with their building footprint or do we see some mapped as points only

# How many school points do not overlap with school polygons
osm_schools$osm_points |> 
  filter(!st_intersects(osm_schools$osm_polygons$geometry |> st_union(), sparse=F)) |> 
  nrow()

# How many school polygons do not overlap with school multipolygons/relations
osm_schools$osm_polygons |> 
  st_point_on_surface() |> 
  filter(!st_intersects(osm_schools$osm_multipolygons$geometry |> st_union(), sparse=F)) |> nrow()

# How many kindergarten points do not overlap with kindergarten polygons
osm_kindergarten$osm_points |> 
  filter(!st_intersects(osm_schools$osm_polygons$geometry |> st_union(), sparse=F)) |> 
  nrow()

# How many kindergarten polygons do not overlap with kindergarten multipolygons/relations
osm_kindergarten$osm_polygons |> 
  st_point_on_surface() |> 
  filter(!st_intersects(osm_schools$osm_multipolygons$geometry |> st_union(), sparse=F)) |> nrow()

# overview on types and objects
datatable(data.frame(object=c(rep("kindergarten",3),rep("school",3)),type=rep(c("nodes","ways","relations"),2), n=c(osm_kindergarten$osm_lines |> nrow(), osm_kindergarten$osm_polygons |> nrow(), osm_kindergarten$osm_multipolygons |> nrow(), osm_schools$osm_points |> nrow(), osm_schools$osm_polygons |> nrow(), osm_schools$osm_multipolygons |> nrow())))


# generate the centroid/point of surface for all school and kindergarten buildings
schools <- osm_schools$osm_polygons |> st_point_on_surface() |>
  filter(st_intersects(geometry, hd_boundary$geometry, sparse=F))
kindergartens <- osm_kindergarten$osm_polygons |> st_point_on_surface() |>
  filter(st_intersects(geometry, hd_boundary$geometry, sparse=F))

```

OpenStreetMap (OSM) is a collaborative map of the world created by people like you and me. The data model of OpenStreetMap consists of three main elements: nodes, ways, and relations.

-   *Nodes*: Nodes are the basic building blocks of the map. Think of them as small points on the map representing specific geographic features, such as a single tree, a streetlamp, a shop, or even a significant landmark like the Eiffel Tower. Each node is defined by its unique latitude and longitude coordinates, which pinpoint its exact location on the Earth's surface.

-   *Ways*: Ways are like paths or lines connecting multiple nodes. They represent linear features like roads, rivers, railway tracks, and footpaths. A way is created by connecting multiple nodes in sequence. For example, a road can be represented as a way by connecting a series of nodes that follow the path of the road.

-   *Relations*: Relations are a way to describe more complex and interconnected features on the map. They group multiple nodes, ways, or even other relations together to represent things like bus routes, building outlines, or multi-part structures. Relations allow us to create more detailed and organized representations of the real world.

Example of a school relation in Heidelberg is the _Kurf√ºrst-Friedrich-Gymnasium_ which has 5 buildings and two distinct locations (https://www.openstreetmap.org/relation/13561009)

Amount of school buildings in Heidelberg: `r nrow(schools)`

Amount of kindergarten buildings in Heidelberg: `r nrow(kindergartens)`

Amount of cigarette vending machines: `r nrow(cvm)`

# ESDA

Calculate distances between each school/kindergarten and CVM location. Aggregate the resulting matrix rowwise (by school/kindergarten) to get the minimum distance towards every distinct CVM.

```{r distances}

dist_mat_schools <- st_distance(schools, cvm)
dist_mat_kindergartens <- st_distance(kindergartens, cvm)

distinct_min_schools <- apply(dist_mat_schools, 1, min)
distinct_min_kindergartens <- apply(dist_mat_kindergartens, 1, min)


```

| Type         | Extreme | Distance                                        |
|--------------|---------|-------------------------------------------------|
| kindergarte  | min     | `r min(distinct_min_kindergartens) |> round(3)` |
| kindergarten | max     | `r max(distinct_min_kindergartens) |> round(3)` |
| school       | min     | `r min(distinct_min_schools) |> round(3)`       |
| school       | min     | `r max(distinct_min_schools) |> round(3)`       |

Furthest distance towards a CVM is \~ 2600 Meter. We create a continuous dataframe with values from 0 to 2600 Meter and add cumulative counts for CVM within the respective distance to/from schools/kindergartens.

```{r data crunch}
breaks <- seq(0, 2600, by = 1)  # Adjust the 'by' value as per your requirement

dist_counts_schools <- table(cut(distinct_min_schools, breaks = breaks, right = FALSE))
dist_counts_kindergartens <- table(cut(distinct_min_kindergartens, breaks = breaks, right = FALSE))

result_df <- data.frame(distance = breaks[2:length(breaks)],
                        cvm_count_schools = as.numeric(dist_counts_schools),
                        cvm_count_kindergartens = as.numeric(dist_counts_kindergartens))

result_df <- result_df |>
  mutate(cvm_count_schools_cum = cumsum(cvm_count_schools),
         cvm_count_kindergartens_cum = cumsum(cvm_count_kindergartens))

```

# Viz

```{r simple plot}
plot(result_df$distance, result_df$cvm_count_kindergartens_cum, type = "l", col = "blue", lwd = 2,
     xlab = "Distance in m", ylab = "cumulative count", main = "CVM distance to schools/kindergartens")
lines(result_df$distance, result_df$cvm_count_schools_cum, col = "green", lwd = 2)
legend("topleft", legend = c("kindergartens", "schools"), col = c("blue", "green"), lwd = 2, lty = 1)


# zoom 0 - 150

plot(result_df$distance[1:150], result_df$cvm_count_kindergartens_cum[1:150], type = "l", col = "blue", lwd = 2,
     xlab = "Distance in m", ylab = "cumulative count", main = "CVM distance to schools/kindergartens")
lines(result_df$distance[1:150], result_df$cvm_count_schools_cum[1:150], col = "green", lwd = 2)
legend("topleft", legend = c("kindergartens", "schools"), col = c("blue", "green"), lwd = 2, lty = 1)


```

The first plot indicates a steep growth in CVM locations within 0 - 500 meters distance to/from schools & kindergartens. However when zoomed in we see less than 10 schools and less than 30 kindergartens are within the first 100m.

But how many are exactly within 100m?

```{r cutoff100}

result_df |> 
  filter(distance<=100) |> 
  summarize(schools=sum(cvm_count_schools),
            kindergartens=sum(cvm_count_kindergartens))

```

```{r map, fig.width=6}
tmap_mode("view")

facilities <- rbind(schools |> select(c(amenity)),
                 kindergartens |> select(c(amenity)))

facilities_buff100 <- facilities |> st_transform(25832) |> st_buffer(100) |> st_transform(4326)

facilities_buff200 <- facilities |> st_transform(25832) |> st_buffer(200) |> st_transform(4326)

tm_basemap("OpenStreetMap") +
  tm_shape(facilities) +
  tm_symbols(
    col = "amenity",
    palette = c("darkgreen", "darkred"),
    size = 0.1,
    border.lwd = 0
  ) +
  tm_shape(cvm) +
  tm_symbols(col = "black", size = 0.1) +
  tm_shape(facilities_buff100) +
  tm_borders(col="grey50") +
  tm_shape(facilities_buff200) +
  tm_borders(col="grey25")

```

# Model

```{r poisson regression}

schools_m <- glm(cvm_count_schools_cum ~ distance, data = result_df, family = poisson)
summary(schools_m)
ggpredict(schools_m)

kindergarten_m <- glm(cvm_count_kindergartens_cum ~ distance, data = result_df, family = poisson)
summary(kindergarten_m)
ggpredict(kindergarten_m)

```

```{r point pattern}

cvm_ppp <- cvm |> st_transform(25832) |> as.ppp()
marks(cvm_ppp) <- NULL

hd_owin <- hd_boundary |> st_transform(25832) |> as.owin()
Window(cvm_ppp) <- hd_owin

ripley_K <- Kest(cvm_ppp, correction = "Ripley")
plot(ripley_K, main = "Ripley's K Function")
```

The K function indicates the location of CVMs are not subject to complete spatial randomness, but are clustered.
